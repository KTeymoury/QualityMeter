"""
Here we will use the properties generated by the properties to measure understandability.

"""

from .quality_attribute import QualityAttribute

from qualitymeter.properties.coupling import Coupling
from qualitymeter.properties.cohesion import Cohesion

class Understandability(QualityAttribute):
    def __init__(self, streams):
        self.streams = streams
        self.__classes = []

    def find_parent(self, parent):
        result = [x for x in self.__classes if x.identifier.getText() == parent.identifier]
        return result

    def walk_the_tree(self):
        for stream in self.streams:
            listener = QualityAttribute.__init__(self, stream)
            for cls in listener.classes:
                self.__classes.append(cls)

    def calc_coupling(self):
        """
        calculating coupling.

        :return: results
        """
        listener = Coupling(self.common_listener.classes_name)
        self.walker.walk(listener, self.parse_tree)
        return sum(listener.result) / len(listener.result)

    def calc_cohesion(self):
        """
        calculating cohesion.

        :return: results
        """
        listener = Cohesion(self.common_listener.classes)
        self.walker.walk(listener, self.parse_tree)
        return sum(listener.result) / len(listener.result)

    def calc_design_size(self):
        """
        calculating design size.
        we want the count of all the classes in our project.

        :return: count of all the classes
        """
        result = 0
        for _ in self.__classes:
            result += 1

        return result

    def calc_abstraction(self):
        """
        calculating abstraction.

        :return: results
        """
        list_of_ancestors = []
        for cls in self.__classes:
            depth = 0
            temp = cls
            while len(temp.parents) != 0:
                depth += 1
                parent = self.find_parent(cls.parents[0])
                if len(parent) == 0:
                    break;
                else:
                    temp = parent[0]
            list_of_ancestors.append(depth)

        if len(list_of_ancestors) != 0:
            result = sum(list_of_ancestors) / len(list_of_ancestors)
        else:
            result = 0

        return result

    def calc_encapsulation(self):
        """
        calculating encapsulation.

        :return: results
        """
        list_of_ratio = []
        for cls in self.__classes:
            atr_count = 0
            atr_private_count = 0
            if len(cls.attributes) != 0:
                for atr in cls.attributes:
                    atr_count += 1
                    if "private" in atr.modifiers or "protected" in atr.modifiers:
                        atr_private_count += 1
                list_of_ratio.append(atr_private_count / atr_count)
            else:
                list_of_ratio.append(0)

        if len(list_of_ratio) != 0:
            result = sum(list_of_ratio) / len(list_of_ratio)
        else:
            result = 0

        return result

    def calc_polymorphism(self):
        """
        calculating polymorphism.

        :return: results
        """

        polymorphic_methods = 0
        for cls in self.__classes:
            if len(cls.implementation) != 0:
                polymorphic_methods += len(cls.methods)

        return polymorphic_methods

    def calc_complexity(self):
        """
        calculating complexity.

        :return: results
        """
        list_of_methods = []
        for cls in self.__classes:
            list_of_methods.append(len(cls.methods))

        if len(list_of_methods) != 0:
            result = sum(list_of_methods)/len(list_of_methods)
        else:
            result = 0

        return result

    def get_value(self):
        """
        returning the final results along the Design Property metrics.

        :return: understandability, coupling, cohesion, design_size, abstraction, encapsulation, polymorphism, complexity
        """
        self.walk_the_tree()

        # coupling = self.calc_coupling()
        # cohesion = self.calc_cohesion()
        design_size = self.calc_design_size()
        abstraction = self.calc_abstraction()
        encapsulation = self.calc_encapsulation()
        polymorphism = self.calc_polymorphism()
        complexity = self.calc_complexity()

        print(design_size)
        print(abstraction)
        print(encapsulation)
        print(polymorphism)
        print(complexity)

        understandability = -0.33 * abstraction + 0.33 * encapsulation - 0.33 * coupling + 0.33 * cohesion\
                            - 0.33 * polymorphism - 0.33 * complexity - 0.33 * design_size

        return understandability, coupling, cohesion, design_size, abstraction, encapsulation, polymorphism, complexity
